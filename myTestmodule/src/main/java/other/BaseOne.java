package other;

public class BaseOne {

    public static void main(String[] args) {
        //二进制的最高位是符号位（“0”代表正数，“1”代表负数）

        //整数
        //以 int 类型为例，int类型占4个字节、共32位。
/*        1.  原码：将一个整数转换成二进制表示

        例如，2 的原码为：00000000 00000000 00000000 00000010

                -2的原码为：10000000 00000000 00000000 00000010



        2. 反码
        正数的反码：与原码相同

        负数的反码：原码的符号位不变，其他位取反

        例如，-2 的反码为：11111111 11111111 11111111 11111101



        3. 补码
        正数的补码：与原码相同

        负数的补码：反码+1

        例如，-2 的补码为：01111111 11111111 11111111 11111110*/


        //小数
/*        32位单精度二进制 = [1个符号位] [8个阶码位] [23个尾数位]

        64位单精度二进制 = [1个符号位] [11个阶码位] [52个尾数位]

        小数 = [正负符号位]  [整数部分] . [小数部分]

        8位阶码位移码偏移量127，11位阶码位移码偏移量1023



        一、小数转换成单精度二进制

        以32位单精度为例：

        小数=-36.35

        第一步：符号位，负用1表示，正的用0，所以[1个符号位] 是1

        第二步：整数直接转换成二进制

　　十进制36 = 二进制0010 0100

        第三步：将小数转换成二进制

　　十进制0.35 = 二进制0101 1001 1001 1001 10001 1001 其中1001循环

        计算过程：  0.35 x 2 = 0.7取整得0 取上次结果的小数部分乘以2

        0.7 x 2 = 1.4取整得1  取0.7的小数部分即0.7乘以2

        0.4 x 2 = 0.8取整得0  取1.4的小数部分即0.4乘以2

        0.8 x 2 = 1.6取整得1  取1.6的小数部分0.6乘以2

        0.6 x 2 = 1.2取整得1  取上次结果的小数部分乘以2

        0.2 x 2 = 0.4取整得0

        0.4 x 2 = 0.8取整得0

                                   ...循环

        第三步：移动小数点计算阶码

　整数二进制.小数二进制

　=0010 0100.0101 1001 1001 1001 10001 1001

　移动小数点，使二进制变成1.xxx*2n形式（规格化）

　=001.0 0100 0101 1001 1001 1001 10001 1001*25

        去掉1.xxx前面的0

                =1.0 0100 0101 1001 1001 1001 10001 1001*25

        指数的真值是5加上(8位阶码位移码偏移量127)=132

        5 + 127 = 132

        132的二进制是1000 0100 所以[8个阶码位]是1000 0100

        第四步：取1.xxx形式小数点后23位得到[23个尾数位]=0 0100 0101 1001 1001 1001 10001 1001 .. （取23位）

        第五步：组合二进制

　　32位单精度二进制 = [1个符号位] [8个阶码位] [23个尾数位]

　　　　　　　　　　 = [1] [1000 0100] [0 0100 0101 1001 1001 1001 10001 1001 .. （取23位）]

　　　　　　　　　　 = 1 1000 0100 0 0100 0101 1001 1001 1001 10001 1001 .. （取23位）

        双精度同理



        二、二进制转单精度小数

        以0011 1001 0010 1011 1110 1000 000 0000为例

        第一步：分三段

　　0  0111 0010 010 1011 1110 1000 0000 0000

　　[1个符号位] [8个阶码位] [23个尾数位]

        0表示正数

        第二步：计算指数

　　0111 0010阶码=十进制114，减去8位阶码位移码偏移量127

　　114 - 127 = -13

　　在23位尾数前加1.变成 1.[23个尾数]，然后向左移动13位（负数向左，正数向右）-- 和坐标轴方法一样

        1.010 1011 1110 1000 0000 0000向左移动13位后等于0.0000 0000 0000 0 1010 1011 1110 1000 0000 0000

        第三步：计算小数

　　转换成小数=2-14 + 2-16 + 2-18 + 2-20 + 2-21 + 2-22 + 2-23 + 2-24 + 2-26

                =0.00008197128772735595703125*/


        //在Java中，所有数据的表示方式都是以补码形式来表示，位运算操作的是补码，逆过程得到原码
        //& | ~ ^  << >> >>>

        //& 位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0

        //| 位或：第一个操作数的的第n位于第二个操作数的第n位,只要有一个是1，那么结果的第n为也为1，否则为0

        //~ 位非：操作数的第n位为1，那么结果的第n位为0，反之

        //^ 位异或：第一个操作数的的第n位于第二个操作数的第n位相反，那么结果的第n为也为1，否则为0

        //<< 左移 左移n位后，低位补0

        //>> 带符号右移 右移n位，高位补符号位

        //>>> 无符号右移 高位补0


        System.out.println(5&(-6));

        System.out.println(Integer.toBinaryString(-6));

/*
        ~5
        00000000 00000000 00000000 00000101
        11111111 11111111 11111111 11111010
        11111111 11111111 11111111 11111001

        10000000 00000000 00000000 00000110

        5 << 3
        00000000 00000000 00000000 00000101

        00000 00000000 00000000 00000101000

         -5 << 3
        11111111 11111111 11111111 11111011

        11111 11111111 11111111 11111011000

        5 >> 3

        00000000 00000000 00000000 00000101

        00000000 00000000 00000000 00101000

        -5 >> 3

        11111111 11111111 11111111 11111011

        11111111111 11111111 11111111 11111

        11111111111 11111111 11111111 11110

        10000000000 00000000 00000000 00001

        5 >>> 3

        00000000 00000000 00000000 00000101

        00000000000 00000000 00000000 00000

        -5 >>> 3

        11111111 11111111 11111111 11111011

        00011111111111111111111111111111
        11111111111111111111111111111*/
    }
}
